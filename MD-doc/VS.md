# Пример сравнения: Options API vs Composition API
Рассмотрим небольшой пример, иллюстрирующий разницу. Допустим, у нас компонент списка задач (to-do list) с возможностью добавлять и удалять элементы. Ниже приведены фрагменты кода для Options API и Composition API, реализующие одинаковую логику.

## Пример на Options API:
```js
<template>
  <div>
    <h3>Список дел</h3>
    <input v-model="newItemText" @keyup.enter="addTodo" placeholder="Новая задача" />
    <button @click="addTodo">Добавить</button>
    <button @click="removeLast">Удалить последнее</button>
    <ul>
      <li v-for="(task, index) in tasks" :key="index">{{ task }}</li>
    </ul>
  </div>
</template>

<script>
export default {
  data() {
    return {
      tasks: ["Пойти на пробежку", "Купить продукты"], // начальный список задач
      newItemText: "" // текст новой задачи
    };
  },
  methods: {
    addTodo() {
      if (this.newItemText.trim() !== "") {
        this.tasks.push(this.newItemText);
        this.newItemText = "";
      }
    },
    removeLast() {
      this.tasks.pop();
    }
  }
};
</script>
```

## Пример на Composition API (тот же функционал):

```js
<template>
  <div>
    <h3>Список дел</h3>
    <input v-model="newItemText" @keyup.enter="addTodo" placeholder="Новая задача" />
    <button @click="addTodo">Добавить</button>
    <button @click="removeLast">Удалить последнее</button>
    <ul>
      <li v-for="(task, index) in tasks" :key="index">{{ task }}</li>
    </ul>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const tasks = ref(["Пойти на пробежку", "Купить продукты"]); // реактивный массив задач
const newItemText = ref(""); // реактивная строка для ввода новой задачи

function addTodo() {
  if (newItemText.value.trim() !== "") {
    tasks.value.push(newItemText.value);
    newItemText.value = "";
  }
}

function removeLast() {
  tasks.value.pop();
}
</script>
```

Оба варианта работают одинаково с точки зрения пользователя. Но сравните организацию кода:
•	Код разделён на опции: данные объявлены отдельно, методы отдельно. При добавлении нового функционала придётся добавить новые поля в разные секции (например, для счётчика выполненных задач – одно поле в data, один метод в methods, возможно вычисляемое свойство в computed).
•	Все переменные и функции объявлены в одном блоке. Логика добавления и удаления сосредоточена в функциях addTodo и removeLast рядом с определениями данных, которые они используют. Это упрощает понимание: вся функциональность задачи "добавить элемент" видна от начала (переменная newItemText) до конца (функция addTodo) в едином контексте.

Итог: для простого примера разница минимальна, Options API даже может выглядеть короче за счёт отсутствия .value. Однако в сложных компонентах Composition API упрощает группировку кода: можно сгруппировать, например, логику работы с фильтрацией, сетевыми запросами, обработкой пользовательского ввода – и вынести каждую в отдельный composable. С Options API подобного достичь трудно: код одной задачи разбивается по разным опциям, его сложнее поддерживать.

# Краткое сравнение Options API vs Composition API
Для наглядности, приведём небольшую таблицу сравнения:

| **Аспект**             | **Options API** (Vue 2 стиль)                                                                                                                                                                                                             | **Composition API** (Vue 3 стиль)                                                                                                                                                                                                                            |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Структура кода**     | Разделение по опциям: данные, методы, вычисления, и т.д. Логика одной фичи может быть распылена по разным секциям. Легко начать, но в больших компонентах возникает фрагментация кода.                                                    | Разделение по логике: код группируется вокруг функциональных блоков внутри `setup`. Связанные переменные и функции держатся вместе, что улучшает целостность и понимание кода.                                                                               |
| **Реактивность**       | Реактивные данные определяются в `data()` и присваиваются `this`. Vue оборачивает их во внутренние реактивные объекты (через `Vue.observable`). Доступ к данным через `this` (прокси объекта компонента).                                 | Явное создание реактивных переменных через `ref()` или `reactive()`. Доступ к значениям через свойства `.value` (для `ref`). Нет привязки к `this`, работаем с переменными напрямую.                                                                         |
| **Переиспользование**  | Ограничено: для повторного использования логики – миксины или HOC. Миксины могут приводить к конфликтам имён и затрудняют понимание, откуда берётся та или иная переменная. Можно вынести утилиты, но они не имеют доступа к реакции Vue. | Высокое: логика может быть вынесена в **компосаблы** (функции, использующие Composition API и возвращающие реактивные объекты). Компосаблы легко импортировать в разных компонентах. Можно разделять логику по модулям без дублирования кода.                |
| **Типизация**          | Менее очевидная, часто требует явного указания типов, использование `@vue/composition-api` (во Vue 2) или отсановка на `this` затрудняет type inference.                                                                                  | Отличная поддержка TypeScript из коробки. Переменные и возвращаемые значения в `setup()` могут иметь явно указанные типы или выводиться автоматически. Нет магии с `this` – код ближе к стандартному TS.                                                     |
| **Обучаемость**        | Порог входа низкий – достаточно знать основы JS и разметки. Структура компонент предсказуема. Хороший выбор для простых приложений и новичков.                                                                                            | Требует понимания новых концепций (реактивность, композиция). Для опытных разработчиков даёт мощный инструмент, но новичкам может показаться сложнее. Рекомендуется перейти к Composition API после освоения основ Vue.                                      |
| **Поддержка Vue 2**    | Полностью совместим (Options API – основа Vue 2).                                                                                                                                                                                         | В Vue 2 доступен через отдельный плагин (для 2.6) или обновление до Vue 2.7+. Изначально разработан для Vue 3, поэтому старые проекты требуют миграции для использования Composition API.                                                                    |
| **Производительность** | Сопоставима в большинстве случаев. Имеется небольшая надстройка в виде прокси `this`, но для обычных приложений это не узкое место.                                                                                                       | Слегка более эффективен при сборке: компиляция шаблона может напрямую обращаться к переменным (без прокси), лучше сжимаются имена переменных при минификации, что уменьшает размер бандла. В реальных приложениях выгода может быть незначительной, но есть. |

